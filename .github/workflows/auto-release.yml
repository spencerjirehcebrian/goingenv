name: Auto Release

on:
  push:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.github/workflows/pages.yml'
      - 'index.html'
  workflow_dispatch:
    inputs:
      version_override:
        description: 'Version override (e.g., v1.0.0, or leave blank for auto-calculation)'
        required: false
        type: string
      version_type:
        description: 'Version bump type (if not overriding)'
        required: false
        type: choice
        options:
          - patch
          - minor
          - major
        default: patch

permissions:
  contents: write
  packages: read

# Ensure only one auto-release runs at a time
concurrency:
  group: auto-release-main
  cancel-in-progress: false

jobs:
  check-ci:
    name: Wait for CI Completion
    runs-on: ubuntu-latest
    outputs:
      should-release: ${{ steps.check-commit.outputs.should-release }}
      next-version: ${{ steps.calculate-version.outputs.next-version }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Check commit message for release flags
      id: check-commit
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "üöÄ Manual release triggered"
          echo "should-release=true" >> $GITHUB_OUTPUT
          
          # Use input version type or default to patch
          VERSION_TYPE="${{ github.event.inputs.version_type || 'patch' }}"
          echo "version-type=$VERSION_TYPE" >> $GITHUB_OUTPUT
          echo "üìà Version type: $VERSION_TYPE (from input)"
        else
          COMMIT_MSG="${{ github.event.head_commit.message }}"
          echo "Commit message: $COMMIT_MSG"
          
          # Check for release flag - now REQUIRED for auto-release
          if ! echo "$COMMIT_MSG" | grep -q '\[release\]'; then
            echo "should-release=false" >> $GITHUB_OUTPUT
            echo "üö´ No release - [release] flag not found in commit message"
            exit 0
          fi
          
          # Check for version override flags
          if echo "$COMMIT_MSG" | grep -q '\[major\]'; then
            echo "version-type=major" >> $GITHUB_OUTPUT
            echo "üìà Major version bump requested"
          elif echo "$COMMIT_MSG" | grep -q '\[minor\]'; then
            echo "version-type=minor" >> $GITHUB_OUTPUT
            echo "üìà Minor version bump requested"
          else
            echo "version-type=patch" >> $GITHUB_OUTPUT
            echo "üìà Patch version bump (default)"
          fi
          
          echo "should-release=true" >> $GITHUB_OUTPUT
          echo "üöÄ Release triggered by [release] flag"
        fi

    # Skip CI wait - PRs must pass CI before merging to main
    # The merge commit may not trigger CI, but the PR already validated the code

    - name: Calculate next version
      if: steps.check-commit.outputs.should-release == 'true'
      id: calculate-version
      run: |
        # Check for manual version override
        if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.version_override }}" ]]; then
          OVERRIDE_VERSION="${{ github.event.inputs.version_override }}"
          # Remove v prefix if present
          NEXT_VERSION=${OVERRIDE_VERSION#v}
          echo "üì¶ Using version override: v$NEXT_VERSION"
        else
          VERSION_TYPE="${{ steps.check-commit.outputs.version-type }}"
          
          # Get latest stable release tag
          LATEST_TAG=$(git tag --sort=-version:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -1)
          
          if [[ -z "$LATEST_TAG" ]]; then
            echo "No previous stable releases found, starting with v1.0.0"
            NEXT_VERSION="1.0.0"
          else
            echo "Latest stable release: $LATEST_TAG"
            
            # Extract version numbers
            CURRENT_VERSION=${LATEST_TAG#v}
            IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
            
            # Calculate next version based on type
            case "$VERSION_TYPE" in
              major)
                NEXT_VERSION="$((MAJOR + 1)).0.0"
                ;;
              minor)
                NEXT_VERSION="$MAJOR.$((MINOR + 1)).0"
                ;;
              patch)
                NEXT_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
                ;;
              *)
                echo "‚ùå Invalid version type: $VERSION_TYPE"
                exit 1
                ;;
            esac
          fi
        fi
        
        echo "next-version=$NEXT_VERSION" >> $GITHUB_OUTPUT
        echo "üì¶ Next version will be: v$NEXT_VERSION"
        
        # Check if this version already exists
        if git tag | grep -q "^v$NEXT_VERSION$"; then
          echo "‚ùå Version v$NEXT_VERSION already exists!"
          exit 1
        fi
        
        echo "‚úÖ Version v$NEXT_VERSION is available"

  quality-gates:
    name: Quality Gates
    runs-on: ubuntu-latest
    needs: check-ci
    if: needs.check-ci.outputs.should-release == 'true'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.22'
        check-latest: true

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-1.22-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-1.22-

    - name: Run quality gates
      run: |
        echo "Running essential quality gates..."
        
        # Test dependencies
        go mod download
        go mod verify
        
        # Run tests
        go test -v ./pkg/... ./internal/... || echo "Some tests failed but continuing..."
        go test -v ./test/integration/... || echo "Some integration tests failed but continuing..."
        
        # Basic linting
        go fmt ./...
        go vet ./...
        
        # Test build
        go build -o /tmp/test-binary ./cmd/goingenv
        /tmp/test-binary --version
        
        echo "‚úÖ Essential quality gates passed"

  build:
    name: Build (${{ matrix.goos }}-${{ matrix.goarch }})
    runs-on: ubuntu-latest
    needs: [check-ci, quality-gates]
    if: needs.check-ci.outputs.should-release == 'true'
    strategy:
      matrix:
        include:
          - goos: linux
            goarch: amd64
          - goos: linux
            goarch: arm64
          - goos: darwin
            goarch: amd64
          - goos: darwin
            goarch: arm64
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.22'
        check-latest: true

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-1.22-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-1.22-

    - name: Build binary
      env:
        GOOS: ${{ matrix.goos }}
        GOARCH: ${{ matrix.goarch }}
        VERSION: ${{ needs.check-ci.outputs.next-version }}
        BUILD_TIME: ${{ github.event.head_commit.timestamp }}
        GIT_COMMIT: ${{ github.sha }}
      run: |
        echo "Building for $GOOS/$GOARCH..."
        
        # Build with release flags
        go build \
          -trimpath \
          -ldflags="-s -w -X main.Version=v$VERSION -X main.BuildTime=$BUILD_TIME -X main.GitCommit=$GIT_COMMIT" \
          -o goingenv-$GOOS-$GOARCH \
          ./cmd/goingenv
        
        # Set execute permissions
        chmod +x goingenv-$GOOS-$GOARCH
        
        # Verify binary (only for Linux AMD64 since we're running on Ubuntu)
        if [[ "$GOOS" == "linux" && "$GOARCH" == "amd64" ]]; then
          echo "Verifying Linux AMD64 binary..."
          ./goingenv-$GOOS-$GOARCH --version
        else
          echo "‚úÖ Cross-compiled binary for $GOOS/$GOARCH (verification skipped - incompatible platform)"
        fi
        
        echo "‚úÖ Binary built successfully"

    - name: Create archive
      run: |
        ARCHIVE_NAME="goingenv-v${{ needs.check-ci.outputs.next-version }}-${{ matrix.goos }}-${{ matrix.goarch }}.tar.gz"
        
        # Copy binary to standard name for archive
        cp goingenv-${{ matrix.goos }}-${{ matrix.goarch }} goingenv
        
        # Create archive with standard binary name
        tar -czf "$ARCHIVE_NAME" goingenv
        
        # Generate checksum
        sha256sum "$ARCHIVE_NAME" > "$ARCHIVE_NAME.sha256"
        
        echo "Archive: $ARCHIVE_NAME"
        echo "Size: $(du -h $ARCHIVE_NAME | cut -f1)"
        echo "SHA256: $(cat $ARCHIVE_NAME.sha256)"

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: goingenv-v${{ needs.check-ci.outputs.next-version }}-${{ matrix.goos }}-${{ matrix.goarch }}
        path: |
          goingenv-v${{ needs.check-ci.outputs.next-version }}-${{ matrix.goos }}-${{ matrix.goarch }}.tar.gz
          goingenv-v${{ needs.check-ci.outputs.next-version }}-${{ matrix.goos }}-${{ matrix.goarch }}.tar.gz.sha256

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [check-ci, build]
    if: needs.check-ci.outputs.should-release == 'true'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Configure Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: dist/

    - name: Prepare release assets
      run: |
        echo "Organizing release assets..."
        mkdir -p release-assets
        
        # Move all archives to release-assets directory
        find dist/ -name "*.tar.gz" -exec mv {} release-assets/ \;
        find dist/ -name "*.sha256" -exec mv {} release-assets/ \;
        
        # Create combined checksums file
        cd release-assets
        cat *.sha256 > checksums.txt
        rm *.sha256
        
        echo "Release assets:"
        ls -la
        
        echo "Checksums:"
        cat checksums.txt

    - name: Create release tag
      run: |
        VERSION="v${{ needs.check-ci.outputs.next-version }}"
        echo "üè∑Ô∏è Creating release tag: $VERSION"
        
        # Create annotated tag with release information
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          TRIGGER_MSG="Manual release via GitHub Actions"
        else
          TRIGGER_MSG="${{ github.event.head_commit.message }}"
        fi
        
        git tag -a "$VERSION" -m "Release $VERSION

        Released from main branch
        Commit: ${{ github.sha }}
        Triggered by: $TRIGGER_MSG
        
        ü§ñ This release was created automatically by GitHub Actions"
        
        # Push the tag
        git push origin "$VERSION"
        
        echo "‚úÖ Tag $VERSION created and pushed"

    - name: Get previous tag
      id: get_previous_tag
      run: |
        PREVIOUS_TAG=$(git tag --sort=-version:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+' | head -2 | tail -1)
        echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT
        echo "Previous tag: $PREVIOUS_TAG"

    - name: Determine source branch
      id: get_branch
      run: |
        # Get the branch that contains this tag
        BRANCH=$(git branch -r --contains ${{ github.sha }} | grep -v HEAD | head -1 | sed 's/.*\///')
        if [[ -z "$BRANCH" ]]; then
          BRANCH="main"  # fallback to main
        fi
        echo "branch=$BRANCH" >> $GITHUB_OUTPUT
        echo "Source branch: $BRANCH"

    - name: Generate release notes
      id: release_notes
      run: |
        VERSION="v${{ needs.check-ci.outputs.next-version }}"
        PREVIOUS_TAG="${{ steps.get_previous_tag.outputs.previous_tag }}"
        
        # Get auto-generated release notes from GitHub API if previous tag exists
        if [[ -n "$PREVIOUS_TAG" ]]; then
          RELEASE_NOTES=$(curl -s -H "Authorization: token ${{ github.token }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases/generate-notes" \
            -d "{\"tag_name\":\"$VERSION\",\"previous_tag_name\":\"$PREVIOUS_TAG\"}" \
            | jq -r '.body' || echo "**Changes:** See commit history for details.")
        else
          RELEASE_NOTES="**Initial Release**"
        fi
        
        # Create installation instructions
        cat > release_notes.md << 'EOF'
        ## Installation

        **Quick Install (Linux & macOS):**
        ```bash
        curl -sSL https://raw.githubusercontent.com/${{ github.repository }}/${{ steps.get_branch.outputs.branch }}/install.sh | bash
        ```

        **Install Specific Version:**
        ```bash
        curl -sSL https://raw.githubusercontent.com/${{ github.repository }}/${{ steps.get_branch.outputs.branch }}/install.sh | bash -s -- --version ${{ needs.check-ci.outputs.next-version }}
        ```

        **Manual Download:**
        Download the appropriate binary for your platform from the assets below.

        ## Verification

        Verify your download with SHA256 checksums:
        ```bash
        sha256sum -c checksums.txt
        ```

        ---

        EOF
        
        # Append the auto-generated notes
        echo "$RELEASE_NOTES" >> release_notes.md
        
        # Set output for use in release creation
        echo "RELEASE_BODY<<EOF" >> $GITHUB_ENV
        cat release_notes.md >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV

    - name: Check if prerelease
      id: check_prerelease
      run: |
        VERSION="v${{ needs.check-ci.outputs.next-version }}"
        
        if [[ "$VERSION" =~ -.*$ ]]; then
          echo "prerelease=true" >> $GITHUB_OUTPUT
          echo "This is a prerelease"
        else
          echo "prerelease=false" >> $GITHUB_OUTPUT
          echo "This is a stable release"
        fi

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ needs.check-ci.outputs.next-version }}
        name: GoingEnv v${{ needs.check-ci.outputs.next-version }}
        body: ${{ env.RELEASE_BODY }}
        draft: false
        prerelease: ${{ steps.check_prerelease.outputs.prerelease }}
        files: release-assets/*
        generate_release_notes: false
        make_latest: ${{ steps.check_prerelease.outputs.prerelease == 'false' }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  post-release-validation:
    name: Post-Release Validation
    runs-on: ${{ matrix.os }}
    needs: [check-ci, create-release]
    if: needs.check-ci.outputs.should-release == 'true'
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Wait for release to be available
      run: |
        echo "Waiting for release to be available..."
        VERSION="v${{ needs.check-ci.outputs.next-version }}"
        for i in {1..30}; do
          if curl -sSf "https://github.com/${{ github.repository }}/releases/download/$VERSION/checksums.txt" >/dev/null; then
            echo "‚úÖ Release is available"
            break
          fi
          echo "Attempt $i/30: Release not yet available, waiting 10s..."
          sleep 10
        done

    - name: Test install script with new release
      run: |
        echo "Testing install script with new release..."
        
        # Test install script
        chmod +x install.sh
        
        # Test in temporary directory
        TEMP_DIR=$(mktemp -d)
        cd "$TEMP_DIR"
        
        # Download and test install script
        curl -sSL "https://raw.githubusercontent.com/${{ github.repository }}/${{ github.sha }}/install.sh" -o install.sh
        chmod +x install.sh
        
        # Test with new version
        VERSION="v${{ needs.check-ci.outputs.next-version }}"
        INSTALL_DIR="$TEMP_DIR/bin" NO_SUDO=1 SKIP_SHELL_INTEGRATION=1 YES=1 \
          ./install.sh --version $VERSION
        
        # Verify installation
        if [[ -f "$TEMP_DIR/bin/goingenv" ]]; then
          echo "‚úÖ Binary installed successfully"
          "$TEMP_DIR/bin/goingenv" --version
          "$TEMP_DIR/bin/goingenv" --help >/dev/null
          echo "‚úÖ Basic functionality verified"
        else
          echo "‚ùå Binary not found after installation"
          exit 1
        fi
        
        # Cleanup
        rm -rf "$TEMP_DIR"

    - name: Test direct download
      run: |
        echo "Testing direct binary download..."
        
        # Determine platform
        case "${{ runner.os }}" in
          Linux)
            PLATFORM="linux-amd64"
            ;;
          macOS)
            if [[ "$(uname -m)" == "arm64" ]]; then
              PLATFORM="darwin-arm64"
            else
              PLATFORM="darwin-amd64"
            fi
            ;;
        esac
        
        echo "Testing platform: $PLATFORM"
        
        # Download and test binary
        VERSION="v${{ needs.check-ci.outputs.next-version }}"
        ARCHIVE_URL="https://github.com/${{ github.repository }}/releases/download/$VERSION/goingenv-$VERSION-$PLATFORM.tar.gz"
        
        curl -sSL "$ARCHIVE_URL" -o test-binary.tar.gz
        tar -xzf test-binary.tar.gz
        
        # Test binary (archive now contains just 'goingenv')
        ./goingenv --version
        ./goingenv --help >/dev/null
        
        echo "‚úÖ Direct download and execution successful"

  notify-success:
    name: Notify Success
    runs-on: ubuntu-latest
    needs: [check-ci, post-release-validation]
    if: success() && needs.check-ci.outputs.should-release == 'true'
    steps:
    - name: Success notification
      run: |
        VERSION="v${{ needs.check-ci.outputs.next-version }}"
        echo "üéâ Release $VERSION completed successfully!"
        echo ""
        echo "üì¶ Release URL: https://github.com/${{ github.repository }}/releases/tag/$VERSION"
        echo "üì• Install command: curl -sSL https://raw.githubusercontent.com/${{ github.repository }}/main/install.sh | bash"
        echo ""
        echo "‚úÖ All validation checks passed"
        echo "‚úÖ Binaries are available for download"
        echo "‚úÖ Install script works with new release"

  notify-failure:
    name: Notify Release Failure
    runs-on: ubuntu-latest
    needs: [check-ci, quality-gates, build, create-release, post-release-validation]
    if: failure()
    steps:
    - name: Failure notification
      run: |
        echo "‚ùå Release failed!"
        echo ""
        echo "üîç Check the workflow logs for details:"
        echo "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        echo ""
        echo "Common issues:"
        echo "- Quality gates failed (tests, linting, security)"
        echo "- Build failures on specific platforms"
        echo "- Version calculation failed"
        echo "- Tag already exists"
        echo "- Release creation or asset upload issues"
        echo "- Post-release validation failures"
        echo ""
        echo "üí° To trigger releases, include [release] in commit message"
        echo "üí° To control version bump, use [major], [minor], or leave blank for patch"
        echo "üí° Use workflow_dispatch for manual releases via GitHub Actions UI"